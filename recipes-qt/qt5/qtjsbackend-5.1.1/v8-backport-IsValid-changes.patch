based on https://bugzilla.redhat.com/show_bug.cgi?id=1331458


From 86c9184ef1083a56f3e05839783634b10707f9ca Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Micha=C3=ABl=20Zasso?= <targos@protonmail.com>
Date: Tue, 3 May 2016 11:27:09 +0200
Subject: [PATCH] deps: backport IsValid changes from 4e8736d in V8

V8 erroneously did null pointer checks on `this`.
It can lead to a SIGSEGV crash if node is compiled with GCC 6.
Backport relevant changes from [1] that fix this issue.

[1]: https://codereview.chromium.org/1900423002

Fixes: https://github.com/nodejs/node/issues/6272

---
 deps/v8/src/heap/incremental-marking.cc |  4 ++--
 deps/v8/src/heap/spaces-inl.h           |  4 ++--
 deps/v8/src/heap/spaces.cc              |  2 +-
 deps/v8/src/heap/spaces.h               |  4 ++--
 deps/v8/test/cctest/heap/test-spaces.cc | 10 +++++-----
 5 files changed, 12 insertions(+), 12 deletions(-)
Index: qtjsbackend-opensource-src-5.1.1/src/3rdparty/v8/src/incremental-marking.cc
===================================================================
--- qtjsbackend-opensource-src-5.1.1.orig/src/3rdparty/v8/src/incremental-marking.cc
+++ qtjsbackend-opensource-src-5.1.1/src/3rdparty/v8/src/incremental-marking.cc
@@ -374,7 +374,7 @@ void IncrementalMarking::DeactivateIncre
   DeactivateIncrementalWriteBarrierForSpace(heap_->new_space());
 
   LargePage* lop = heap_->lo_space()->first_page();
-  while (lop->is_valid()) {
+  while (LargePage::IsValid(lop)) {
     SetOldSpacePageFlags(lop, false, false);
     lop = lop->next_page();
   }
@@ -408,7 +408,7 @@ void IncrementalMarking::ActivateIncreme
   ActivateIncrementalWriteBarrier(heap_->new_space());
 
   LargePage* lop = heap_->lo_space()->first_page();
-  while (lop->is_valid()) {
+  while (LargePage::IsValid(lop)) {
     SetOldSpacePageFlags(lop, true, is_compacting_);
     lop = lop->next_page();
   }
Index: qtjsbackend-opensource-src-5.1.1/src/3rdparty/v8/src/spaces-inl.h
===================================================================
--- qtjsbackend-opensource-src-5.1.1.orig/src/3rdparty/v8/src/spaces-inl.h
+++ qtjsbackend-opensource-src-5.1.1/src/3rdparty/v8/src/spaces-inl.h
@@ -177,7 +177,7 @@ Page* Page::Initialize(Heap* heap,
 
 bool PagedSpace::Contains(Address addr) {
   Page* p = Page::FromAddress(addr);
-  if (!p->is_valid()) return false;
+  if (!Page::IsValid(p)) return false;
   return p->owner() == this;
 }
 
Index: qtjsbackend-opensource-src-5.1.1/src/3rdparty/v8/src/spaces.cc
===================================================================
--- qtjsbackend-opensource-src-5.1.1.orig/src/3rdparty/v8/src/spaces.cc
+++ qtjsbackend-opensource-src-5.1.1/src/3rdparty/v8/src/spaces.cc
@@ -2392,7 +2392,7 @@ HeapObject* PagedSpace::SlowAllocateRaw(
 
   // If there are unswept pages advance lazy sweeper then sweep one page before
   // allocating a new page.
-  if (first_unswept_page_->is_valid()) {
+  if (Page::IsValid(first_unswept_page_)) {
     AdvanceSweeper(size_in_bytes);
 
     // Retry the free list allocation.
@@ -2764,7 +2764,7 @@ LargePage* LargeObjectSpace::FindPage(Ad
   if (e != NULL) {
     ASSERT(e->value != NULL);
     LargePage* page = reinterpret_cast<LargePage*>(e->value);
-    ASSERT(page->is_valid());
+    ASSERT(LargePage::IsValid(page));
     if (page->Contains(a)) {
       return page;
     }
Index: qtjsbackend-opensource-src-5.1.1/src/3rdparty/v8/src/spaces.h
===================================================================
--- qtjsbackend-opensource-src-5.1.1.orig/src/3rdparty/v8/src/spaces.h
+++ qtjsbackend-opensource-src-5.1.1/src/3rdparty/v8/src/spaces.h
@@ -307,9 +307,9 @@ class MemoryChunk {
   // Only works for addresses in pointer spaces, not data or code spaces.
   static inline MemoryChunk* FromAnyPointerAddress(Address addr);
 
-  Address address() { return reinterpret_cast<Address>(this); }
+  static bool IsValid(MemoryChunk* chunk) { return chunk != NULL; }
 
-  bool is_valid() { return address() != NULL; }
+  Address address() { return reinterpret_cast<Address>(this); }
 
   MemoryChunk* next_chunk() const { return next_chunk_; }
   MemoryChunk* prev_chunk() const { return prev_chunk_; }
@@ -1642,7 +1642,7 @@ class PagedSpace : public Space {
   bool AdvanceSweeper(intptr_t bytes_to_sweep);
 
   bool IsSweepingComplete() {
-    return !first_unswept_page_->is_valid();
+    return !Page::IsValid(first_unswept_page_);
   }
 
   Page* FirstPage() { return anchor_.next_page(); }
Index: qtjsbackend-opensource-src-5.1.1/src/3rdparty/v8/test/cctest/test-spaces.cc
===================================================================
--- qtjsbackend-opensource-src-5.1.1.orig/src/3rdparty/v8/test/cctest/test-spaces.cc
+++ qtjsbackend-opensource-src-5.1.1/src/3rdparty/v8/test/cctest/test-spaces.cc
@@ -74,11 +74,11 @@ TEST(Page) {
   // Initialized Page has heap pointer, normally set by memory_allocator.
   p->heap_ = HEAP;
   CHECK(p->address() == page_start);
-  CHECK(p->is_valid());
+  CHECK(Page::IsValid(p));
 
   p->opaque_header = 0;
   p->SetIsLargeObjectPage(false);
-  CHECK(!p->next_page()->is_valid());
+  CHECK(!Page::IsValid(p->next_page()));
 
   CHECK(p->ObjectAreaStart() == page_start + Page::kObjectStartOffset);
   CHECK(p->ObjectAreaEnd() == page_start + Page::kPageSize);
@@ -144,7 +144,7 @@ TEST(MemoryAllocator) {
       faked_space.AreaSize(), &faked_space, NOT_EXECUTABLE);
 
   first_page->InsertAfter(faked_space.anchor()->prev_page());
-  CHECK(first_page->is_valid());
+  CHECK(Page::IsValid(first_page));
   CHECK(first_page->next_page() == faked_space.anchor());
   total_pages++;
 
@@ -155,7 +155,7 @@ TEST(MemoryAllocator) {
   // Again, we should get n or n - 1 pages.
   Page* other = memory_allocator->AllocatePage(
       faked_space.AreaSize(), &faked_space, NOT_EXECUTABLE);
-  CHECK(other->is_valid());
+  CHECK(Page::IsValid(other));
   total_pages++;
   other->InsertAfter(first_page);
   int page_count = 0;
@@ -166,7 +166,7 @@ TEST(MemoryAllocator) {
   CHECK(total_pages == page_count);
 
   Page* second_page = first_page->next_page();
-  CHECK(second_page->is_valid());
+  CHECK(Page::IsValid(second_page));
   memory_allocator->Free(first_page);
   memory_allocator->Free(second_page);
   memory_allocator->TearDown();
