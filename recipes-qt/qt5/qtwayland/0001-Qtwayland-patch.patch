From 798b1cd8998debd3349a9ac4e13fb67bd12e21e6 Mon Sep 17 00:00:00 2001
From: mthirumalai <MadanaGopal.Thirumalai@LntTechservices.com>
Date: Mon, 01 Feb 2016 18:49:43 +0530
Subject: [PATCH] XRE-8830 - Building QtWayland 5.4 with Qt 5.1.1 [pace xi3 master]

Reason for change: Modified qtwayland to run with qt5.1. To bring wayland platform support
Test Procedure: Run qt application with QT_QPA_PLATFORM as wayland-egl
                Provide --wayland-scoket-name for any wayland display other than wayland-0
Risks: None

Change-Id: Ia2d23f1712f5893b052ebd0335fc89c5e0b7a63e
Signed-off-by: mthirumalai <MadanaGopal.Thirumalai@LntTechservices.com>
---

diff --git a/examples/wayland/qwindow-compositor/qwindowcompositor.cpp b/examples/wayland/qwindow-compositor/qwindowcompositor.cpp
index ab6722a..d322bc8 100644
--- a/examples/wayland/qwindow-compositor/qwindowcompositor.cpp
+++ b/examples/wayland/qwindow-compositor/qwindowcompositor.cpp
@@ -44,13 +44,18 @@
 #include <QKeyEvent>
 #include <QTouchEvent>
 #include <QOpenGLFunctions>
-#include <QOpenGLTexture>
+// COMCAST MODIFICATION BEGIN
+//#include <QOpenGLTexture>
+// COMCAST MODIFICATION END
 #include <QGuiApplication>
 #include <QCursor>
 #include <QPixmap>
 #include <QLinkedList>
 #include <QScreen>
 #include <QPainter>
+// COMCAST MODIFICATION BEGIN
+#include <QtOpenGL/QGLWidget>
+// COMCAST MODIFICATION END
 
 #include <QtCompositor/qwaylandinput.h>
 #include <QtCompositor/qwaylandbufferref.h>
@@ -63,21 +68,28 @@
 public:
     BufferAttacher()
         : QWaylandBufferAttacher()
-        , shmTex(0)
+// COMCAST MODIFICATION BEGIN
+       // , shmTex(0)
+// COMCAST MODIFICATION END
     {
     }
 
     ~BufferAttacher()
     {
-        delete shmTex;
+// COMCAST MODIFICATION BEGIN
+ //       delete shmTex;
+// COMCAST MODIFICATION END
     }
 
     void attach(const QWaylandBufferRef &ref) Q_DECL_OVERRIDE
     {
         if (bufferRef) {
             if (bufferRef.isShm()) {
-                delete shmTex;
-                shmTex = 0;
+// COMCAST MODIFICATION BEGIN
+                // delete shmTex;
+                // shmTex = 0;
+                glDeleteTextures(1, &texture);
+// COMCAST MODIFICATION END
             } else {
                 bufferRef.destroyTexture();
             }
@@ -87,9 +99,23 @@
 
         if (bufferRef) {
             if (bufferRef.isShm()) {
-                shmTex = new QOpenGLTexture(bufferRef.image(), QOpenGLTexture::DontGenerateMipMaps);
-                shmTex->setWrapMode(QOpenGLTexture::ClampToEdge);
-                texture = shmTex->textureId();
+// COMCAST MODIFICATION BEGIN
+                // shmTex = new QOpenGLTexture(bufferRef.image(), QOpenGLTexture::DontGenerateMipMaps);
+                // shmTex->setWrapMode(QOpenGLTexture::ClampToEdge);
+                // texture = shmTex->textureId();
+                QImage invertedImage = bufferRef.image().mirrored(false,true);
+                QImage GL_formatted_image;
+                GL_formatted_image = QGLWidget::convertToGLFormat(invertedImage);
+                glGenTextures( 1, &texture);
+                glBindTexture( GL_TEXTURE_2D, texture);
+                glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, GL_formatted_image.width(),
+                        GL_formatted_image.height(),0, GL_RGBA, GL_UNSIGNED_BYTE, GL_formatted_image.bits());
+                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+                glBindTexture(GL_TEXTURE_2D, 0);
+// COMCAST MODIFICATION END
             } else {
                 texture = bufferRef.createTexture();
             }
@@ -103,7 +129,9 @@
         return bufferRef.image();
     }
 
-    QOpenGLTexture *shmTex;
+// COMCAST MODIFICATION BEGIN
+    // QOpenGLTexture *shmTex;
+// COMCAST MODIFICATION END
     QWaylandBufferRef bufferRef;
     GLuint texture;
 };
@@ -315,15 +343,25 @@
 
     cleanupGraphicsResources();
 
-    if (!m_backgroundTexture)
-        m_backgroundTexture = new QOpenGLTexture(m_backgroundImage, QOpenGLTexture::DontGenerateMipMaps);
+// COMCAST MODIFICATION BEGIN
+    if (!m_backgroundTexture) {
+        QImage image = m_backgroundImage.convertToFormat(QImage::Format_RGB888);
+        glGenTextures(1, &m_backgroundTexture);
+        glBindTexture(GL_TEXTURE_2D, m_backgroundTexture);
+        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, image.width(), image.height(),0, GL_RGB, GL_UNSIGNED_BYTE, image.bits());
+        glBindTexture(GL_TEXTURE_2D, 0);
+    }
+// COMCAST MODIFICATION END
 
     m_textureBlitter->bind();
     // Draw the background image texture
-    m_textureBlitter->drawTexture(m_backgroundTexture->textureId(),
-                                  QRect(QPoint(0, 0), m_backgroundImage.size()),
-                                  window()->size(),
-                                  0, false, true);
+// COMCAST MODIFICATION BEGIN
+    //m_textureBlitter->drawTexture(m_backgroundTexture->textureId(),
+    m_textureBlitter->drawTexture(m_backgroundTexture,
+            QRect(QPoint(0, 0), m_backgroundImage.size()),
+            window()->size(),
+            0, false, true);
+// COMCAST MODIFICATION END
 
     foreach (QWaylandSurface *surface, m_surfaces) {
         if (!surface->visible())
diff --git a/examples/wayland/qwindow-compositor/qwindowcompositor.h b/examples/wayland/qwindow-compositor/qwindowcompositor.h
index 57f3e85..56a2ff6 100644
--- a/examples/wayland/qwindow-compositor/qwindowcompositor.h
+++ b/examples/wayland/qwindow-compositor/qwindowcompositor.h
@@ -93,7 +93,10 @@
 
     CompositorWindow *m_window;
     QImage m_backgroundImage;
-    QOpenGLTexture *m_backgroundTexture;
+// COMCAST MODIFICATION BEGIN
+    // QOpenGLTexture *m_backgroundTexture;
+    GLuint m_backgroundTexture;
+// COMCAST MODIFICATION END
     QList<QWaylandSurface *> m_surfaces;
     TextureBlitter *m_textureBlitter;
     GLuint m_surface_fbo;
diff --git a/examples/wayland/wayland.pro b/examples/wayland/wayland.pro
index d633fb9..6f0d807 100644
--- a/examples/wayland/wayland.pro
+++ b/examples/wayland/wayland.pro
@@ -9,5 +9,7 @@
         SUBDIRS += qml-compositor
     }
 
-    SUBDIRS += server-buffer
+#COMCAST MODIFICATION BEGIN
+    #SUBDIRS += server-buffer
+#COMCAST MODIFICATION END
 }
diff --git a/src/3rdparty/protocol/wayland.xml b/src/3rdparty/protocol/wayland.xml
index 1442b6a..da80f3b 100644
--- a/src/3rdparty/protocol/wayland.xml
+++ b/src/3rdparty/protocol/wayland.xml
@@ -1171,8 +1171,9 @@
       <arg name="scale" type="int"/>
     </request>
    </interface>
-
-  <interface name="wl_seat" version="2">
+  <!-- COMCAST MODIFICATION BEGIN -->
+  <interface name="wl_seat" version="5">
+  <!-- COMCAST MODIFICATION END -->
     <description summary="group of input devices">
       A seat is a group of keyboards, pointer and touch devices. This
       object is published as a global during start up, or when such a
diff --git a/src/3rdparty/protocol/xdg-shell.xml b/src/3rdparty/protocol/xdg-shell.xml
index 79a2831..275837f 100644
--- a/src/3rdparty/protocol/xdg-shell.xml
+++ b/src/3rdparty/protocol/xdg-shell.xml
@@ -45,7 +45,7 @@
 	they implement using static_assert to ensure the protocol and
 	implementation versions match.
       </description>
-      <entry name="current" value="3" summary="Always the latest version"/>
+      <entry name="current" value="4" summary="Always the latest version"/>
     </enum>
 
 
@@ -137,42 +137,13 @@
       </description>
     </request>
 
-    <request name="set_transient_for">
+    <request name="set_parent">
       <description summary="surface is a child of another surface">
-	Setting a surface as transient of another means that it is child
-	of another surface.
-
 	Child surfaces are stacked above their parents, and will be
 	unmapped if the parent is unmapped too. They should not appear
 	on task bars and alt+tab.
       </description>
       <arg name="parent" type="object" interface="wl_surface" allow-null="true"/>
-    </request>
-
-    <request name="set_margin">
-      <description summary="set the visible frame boundaries">
-        This tells the compositor what the visible size of the window
-        should be, so it can use it to determine what borders to use for
-        constrainment and alignment.
-
-        CSD often has invisible areas for decoration purposes, like drop
-        shadows. These "shadow" drawings need to be subtracted out of the
-        normal boundaries of the window when computing where to place
-        windows (e.g. to set this window so it's centered on top of another,
-        or to put it to the left or right of the screen.)
-
-        This value should change as little as possible at runtime, to
-        prevent flicker.
-
-        This value is also ignored when the window is maximized or
-        fullscreen, and assumed to be 0.
-
-        If never called, this value is assumed to be 0.
-      </description>
-      <arg name="left_margin" type="int"/>
-      <arg name="right_margin" type="int"/>
-      <arg name="top_margin" type="int"/>
-      <arg name="bottom_margin" type="int"/>
     </request>
 
     <request name="set_title">
@@ -199,6 +170,26 @@
 	specification, the interface name.
       </description>
       <arg name="app_id" type="string"/>
+    </request>
+
+    <request name="show_window_menu">
+      <description summary="show the window menu">
+        Clients implementing client-side decorations might want to show
+        a context menu when right-clicking on the decorations, giving the
+        user a menu that they can use to maximize or minimize the window.
+
+        This request asks the compositor to pop up such a window menu at
+        the given position, relative to the parent surface. There are
+        no guarantees as to what the window menu contains.
+
+        Your surface must have focus on the seat passed in to pop up the
+        window menu.
+      </description>
+
+      <arg name="seat" type="object" interface="wl_seat" summary="the seat to pop the window up on"/>
+      <arg name="serial" type="uint" summary="serial of the event to pop up the window for"/>
+      <arg name="x" type="int" summary="the x position to pop up the window menu at"/>
+      <arg name="y" type="int" summary="the y position to pop up the window menu at"/>
     </request>
 
     <request name="move">
@@ -244,46 +235,12 @@
       <arg name="edges" type="uint" summary="which edge or corner is being dragged"/>
     </request>
 
-    <event name="configure">
-      <description summary="suggest resize">
-	The configure event asks the client to resize its surface.
-
-	The size is a hint, in the sense that the client is free to
-	ignore it if it doesn't resize, pick a smaller size (to
-	satisfy aspect ratio or resize in steps of NxM pixels).
-
-	The client is free to dismiss all but the last configure
-	event it received.
-
-	The width and height arguments specify the size of the window
-	in surface local coordinates.
-      </description>
-
-      <arg name="width" type="int"/>
-      <arg name="height" type="int"/>
-    </event>
-
-    <request name="set_output">
-      <description summary="set the default output used by this surface">
-	Set the default output used by this surface when it is first mapped.
-
-	If this value is NULL (default), it's up to the compositor to choose
-	which display will be used to map this surface.
-
-	When fullscreen or maximized state are set on this surface, and it
-	wasn't mapped yet, the output set with this method will be used.
-	Otherwise, the output where the surface is currently mapped will be
-	used.
-      </description>
-      <arg name="output" type="object" interface="wl_output" allow-null="true"/>
-    </request>
-
     <enum name="state">
       <description summary="types of state on the surface">
         The different state values used on the surface. This is designed for
         state values like maximized, fullscreen. It is paired with the
-        request_change_state event to ensure that both the client and the
-        compositor setting the state can be synchronized.
+        configure event to ensure that both the client and the compositor
+        setting the state can be synchronized.
 
         States set in this way are double-buffered. They will get applied on
         the next commit.
@@ -300,89 +257,101 @@
         0x1000 - 0x1FFF: GNOME
       </description>
       <entry name="maximized" value="1" summary="the surface is maximized">
-        A non-zero value indicates the surface is maximized. Otherwise,
-        the surface is unmaximized.
+        The surface is maximized. The window geometry specified in the configure
+        event must be obeyed by the client.
       </entry>
       <entry name="fullscreen" value="2" summary="the surface is fullscreen">
-        A non-zero value indicates the surface is fullscreen. Otherwise,
-        the surface is not fullscreen.
+        The surface is fullscreen. The window geometry specified in the configure
+        event must be obeyed by the client.
+      </entry>
+      <entry name="resizing" value="3">
+        The surface is being resized. The window geometry specified in the
+        configure event is a maximum; the client cannot resize beyond it.
+        Clients that have aspect ratio or cell sizing configuration can use
+        a smaller size, however.
+      </entry>
+      <entry name="activated" value="4">
+        Client window decorations should be painted as if the window is
+        active. Do not assume this means that the window actually has
+        keyboard or pointer focus.
       </entry>
     </enum>
 
-    <request name="request_change_state">
-      <description summary="client requests to change a surface's state">
-        This asks the compositor to change the state. If the compositor wants
-        to change the state, it will send a change_state event with the same
-        state_type, value, and serial, and the event flow continues as if it
-        it was initiated by the compositor.
+    <event name="configure">
+      <description summary="suggest a surface change">
+	The configure event asks the client to resize its surface.
 
-        If the compositor does not want to change the state, it will send a
-        change_state to the client with the old value of the state.
-      </description>
-      <arg name="state_type" type="uint" summary="the state to set"/>
-      <arg name="value" type="uint" summary="the value to change the state to"/>
-      <arg name="serial" type="uint" summary="an event serial">
-        This serial is so the client can know which change_state event corresponds
-        to which request_change_state request it sent out.
-      </arg>
-    </request>
+	The width and height arguments specify a hint to the window
+        about how its surface should be resized in window geometry
+        coordinates. The states listed in the event specify how the
+        width/height arguments should be interpreted.
 
-    <event name="change_state">
-      <description summary="compositor wants to change a surface's state">
-        This event tells the client to change a surface's state. The client
-        should respond with an ack_change_state request to the compositor to
-        guarantee that the compositor knows that the client has seen it.
+        A client should arrange a new surface, and then send a
+        ack_configure request with the serial sent in this configure
+        event before attaching a new surface.
+
+	If the client receives multiple configure events before it
+        can respond to one, it is free to discard all but the last
+        event it received.
       </description>
 
-      <arg name="state_type" type="uint" summary="the state to set"/>
-      <arg name="value" type="uint" summary="the value to change the state to"/>
-      <arg name="serial" type="uint" summary="a serial for the compositor's own tracking"/>
+      <arg name="width" type="int"/>
+      <arg name="height" type="int"/>
+      <arg name="states" type="array"/>
+      <arg name="serial" type="uint"/>
     </event>
 
-    <request name="ack_change_state">
-      <description summary="ack a change_state event">
-        When a change_state event is received, a client should then ack it
-        using the ack_change_state request to ensure that the compositor
+    <request name="ack_configure">
+      <description summary="ack a configure event">
+        When a configure event is received, a client should then ack it
+        using the ack_configure request to ensure that the compositor
         knows the client has seen the event.
 
         By this point, the state is confirmed, and the next attach should
-        contain the buffer drawn for the new state value.
-
-        The values here need to be the same as the values in the cooresponding
-        change_state event.
+        contain the buffer drawn for the configure event you are acking.
       </description>
-      <arg name="state_type" type="uint" summary="the state to set"/>
-      <arg name="value" type="uint" summary="the value to change the state to"/>
-      <arg name="serial" type="uint" summary="a serial to pass to change_state"/>
+      <arg name="serial" type="uint" summary="a serial to configure for"/>
     </request>
 
-    <request name="set_minimized">
-      <description summary="minimize the surface">
-        Minimize the surface.
+    <request name="set_window_geometry">
+      <description summary="set the new window geometry">
+        The window geometry of a window is its "visible bounds" from the
+        user's perspective. Client-side decorations often have invisible
+        portions like drop-shadows which should be ignored for the
+        purposes of aligning, placing and constraining windows.
+
+        The default value is the full bounds of the surface, including any
+        subsurfaces. Once the window geometry of the surface is set once,
+        it is not possible to unset it, and it will remain the same until
+        set_window_geometry is called again, even if a new subsurface or
+        buffer is attached.
+
+        If responding to a configure event, the window geometry in here
+        must respect the sizing negotiations specified by the states in
+        the configure event.
       </description>
+      <arg name="x" type="int"/>
+      <arg name="y" type="int"/>
+      <arg name="width" type="int"/>
+      <arg name="height" type="int"/>
     </request>
 
-    <event name="activated">
-      <description summary="surface was activated">
-	The activated_set event is sent when this surface has been
-	activated, which means that the surface has user attention.
-        Window decorations should be updated accordingly. You should
-        not use this event for anything but the style of decorations
-        you display, use wl_keyboard.enter and wl_keyboard.leave for
-        determining keyboard focus.
-      </description>
-    </event>
+    <request name="set_maximized" />
+    <request name="unset_maximized" />
 
-    <event name="deactivated">
-      <description summary="surface was deactivated">
-	The deactivate event is sent when this surface has been
-        deactivated, which means that the surface lost user attention.
-        Window decorations should be updated accordingly. You should
-        not use this event for anything but the style of decorations
-        you display, use wl_keyboard.enter and wl_keyboard.leave for
-        determining keyboard focus.
+    <request name="set_fullscreen">
+      <description summary="set the window as fullscreen on a monitor">
+	Make the surface fullscreen.
+
+        You can specify an output that you would prefer to be fullscreen.
+	If this value is NULL, it's up to the compositor to choose which
+        display will be used to map this surface.
       </description>
-    </event>
+      <arg name="output" type="object" interface="wl_output" allow-null="true"/>
+    </request>
+    <request name="unset_fullscreen" />
+
+    <request name="set_minimized" />
 
     <event name="close">
       <description summary="surface wants to be closed">
diff --git a/src/client/qwaylandbuffer_p.h b/src/client/qwaylandbuffer_p.h
index 6d2bb66..193a671 100644
--- a/src/client/qwaylandbuffer_p.h
+++ b/src/client/qwaylandbuffer_p.h
@@ -55,7 +55,7 @@
 class Q_WAYLAND_CLIENT_EXPORT QWaylandBuffer {
 public:
     QWaylandBuffer()
-        : mBuffer(0)
+        : mBuffer(0) // COMCAST MODIFICATION
     {
     }
     virtual ~QWaylandBuffer() { }
diff --git a/src/client/qwaylandintegration.cpp b/src/client/qwaylandintegration.cpp
index aa5a1ce..6ea6187 100644
--- a/src/client/qwaylandintegration.cpp
+++ b/src/client/qwaylandintegration.cpp
@@ -160,17 +160,27 @@
     case MultipleWindows:
     case NonFullScreenWindows:
         return true;
+// COMCAST MODIFICATION BEGIN
+#if (QT_VERSION > QT_VERSION_CHECK(5, 2, 0))
     case RasterGLSurface:
         return true;
+#endif
+// COMCAST MODIFICATION END
     default: return QPlatformIntegration::hasCapability(cap);
     }
 }
 
 QPlatformWindow *QWaylandIntegration::createPlatformWindow(QWindow *window) const
 {
-    if ((window->surfaceType() == QWindow::OpenGLSurface || window->surfaceType() == QWindow::RasterGLSurface)
-        && mDisplay->clientBufferIntegration())
-        return mDisplay->clientBufferIntegration()->createEglWindow(window);
+    if ((window->surfaceType() == QWindow::OpenGLSurface
+// COMCAST MODIFICATION BEGIN
+#if (QT_VERSION > QT_VERSION_CHECK(5, 2, 0))
+       || window->surfaceType() == QWindow::RasterGLSurface
+#endif
+// COMCAST MODIFICATION END
+        )
+      && mDisplay->clientBufferIntegration())
+      return mDisplay->clientBufferIntegration()->createEglWindow(window);
 
     return new QWaylandShmWindow(window);
 }
@@ -193,6 +203,12 @@
 {
     return createUnixEventDispatcher();
 }
+// COMCAST MODIFICATION BEGIN
+QAbstractEventDispatcher *QWaylandIntegration::guiThreadEventDispatcher() const
+{
+  return createUnixEventDispatcher();
+}
+// COMCAST MODIFICATION END
 
 void QWaylandIntegration::initialize()
 {
diff --git a/src/client/qwaylandintegration_p.h b/src/client/qwaylandintegration_p.h
index 6997024..6e52652 100644
--- a/src/client/qwaylandintegration_p.h
+++ b/src/client/qwaylandintegration_p.h
@@ -67,6 +67,9 @@
     QPlatformBackingStore *createPlatformBackingStore(QWindow *window) const;
 
     QAbstractEventDispatcher *createEventDispatcher() const;
+// COMCAST MODIFICATION BEGIN
+    QAbstractEventDispatcher *guiThreadEventDispatcher() const;
+// COMCAST MODIFICATION END
     void initialize();
 
     QPlatformFontDatabase *fontDatabase() const;
diff --git a/src/client/qwaylandscreen.cpp b/src/client/qwaylandscreen.cpp
index ad10b7a..5d1154d 100644
--- a/src/client/qwaylandscreen.cpp
+++ b/src/client/qwaylandscreen.cpp
@@ -228,7 +228,13 @@
         QWindowSystemInterface::handleScreenOrientationChange(screen(), m_orientation);
         mTransform = -1;
     }
+// COMCAST MODIFICATION BEGIN
+#if (QT_VERSION > QT_VERSION_CHECK(5, 2, 0))
     QWindowSystemInterface::handleScreenGeometryChange(screen(), mGeometry, mGeometry);
+#else
+    QWindowSystemInterface::handleScreenGeometryChange(screen(), mGeometry);
+#endif
+// COMCAST MODIFICATION END
     QWindowSystemInterface::handleScreenRefreshRateChange(screen(), refreshRate());
 }
 
diff --git a/src/client/qwaylandshmbackingstore_p.h b/src/client/qwaylandshmbackingstore_p.h
index c0d730d..25562d2 100644
--- a/src/client/qwaylandshmbackingstore_p.h
+++ b/src/client/qwaylandshmbackingstore_p.h
@@ -96,7 +96,7 @@
     void iterateBuffer();
 
 #ifndef QT_NO_OPENGL
-    QImage toImage() const Q_DECL_OVERRIDE;
+    QImage toImage() const; // COMCAST MODIFICATION
 #endif
 
 private:
diff --git a/src/client/qwaylandwindow.cpp b/src/client/qwaylandwindow.cpp
index 83c44c2..b7a4c2b 100644
--- a/src/client/qwaylandwindow.cpp
+++ b/src/client/qwaylandwindow.cpp
@@ -773,5 +773,17 @@
 {
     return m_properties.value(name, defaultValue);
 }
+// COMCAST MODIFICATION BEGIN
+void QWaylandWindow::commit()
+{
+   QtWayland::wl_surface::commit();
+}
+void QWaylandWindow::surface_enter(struct ::wl_output *output)
+{
+}
+void QWaylandWindow::surface_leave(struct ::wl_output *output)
+{
+}
+// COMCAST MODIFICATION END
 
 QT_END_NAMESPACE
diff --git a/src/client/qwaylandwindow_p.h b/src/client/qwaylandwindow_p.h
index 9ad6fe2..7de6762 100644
--- a/src/client/qwaylandwindow_p.h
+++ b/src/client/qwaylandwindow_p.h
@@ -187,7 +187,11 @@
 
     bool setKeyboardGrabEnabled(bool) Q_DECL_OVERRIDE { return false; }
     void propagateSizeHints() Q_DECL_OVERRIDE { }
-
+// COMCAST MODIFICATION BEGIN
+    void commit();
+    void surface_enter(struct ::wl_output * output);
+    void surface_leave(struct ::wl_output * output);
+// COMCAST MODIFICATION END
 public slots:
     void requestResize();
 
diff --git a/src/client/qwaylandxdgsurface.cpp b/src/client/qwaylandxdgsurface.cpp
index 318ff86..ccb35cc 100644
--- a/src/client/qwaylandxdgsurface.cpp
+++ b/src/client/qwaylandxdgsurface.cpp
@@ -93,31 +93,23 @@
 
 void QWaylandXdgSurface::setMaximized()
 {
-    if (!m_maximized)
-        request_change_state(XDG_SURFACE_STATE_MAXIMIZED, true, 0);
+// COMCAST MODIFICATION BEGIN
+  //Need to be implemented
+// COMCAST MODIFICATION END
 }
 
 void QWaylandXdgSurface::setFullscreen()
 {
-    if (!m_fullscreen)
-        request_change_state(XDG_SURFACE_STATE_FULLSCREEN, true, 0);
+// COMCAST MODIFICATION BEGIN
+  //Need to be implemented
+// COMCAST MODIFICATION END
 }
 
 void QWaylandXdgSurface::setNormal()
 {
-    if (m_fullscreen || m_maximized  || m_minimized) {
-        if (m_maximized) {
-            request_change_state(XDG_SURFACE_STATE_MAXIMIZED, false, 0);
-        }
-        if (m_fullscreen) {
-            request_change_state(XDG_SURFACE_STATE_FULLSCREEN, false, 0);
-        }
-
-        m_fullscreen = m_maximized = m_minimized = false;
-        setTopLevel();
-        QMargins m = m_window->frameMargins();
-        m_window->configure(0, m_size.width() + m.left() + m.right(), m_size.height() + m.top() + m.bottom());
-    }
+// COMCAST MODIFICATION BEGIN
+  //Need to be implemented
+// COMCAST MODIFICATION END
 }
 
 void QWaylandXdgSurface::setMinimized()
@@ -134,26 +126,9 @@
 
 void QWaylandXdgSurface::updateTransientParent(QWindow *parent)
 {
-    QWaylandWindow *parent_wayland_window = static_cast<QWaylandWindow *>(parent->handle());
-    if (!parent_wayland_window)
-        return;
-
-    // set_transient expects a position relative to the parent
-    QPoint transientPos = m_window->geometry().topLeft(); // this is absolute
-    QWindow *parentWin = m_window->window()->transientParent();
-    transientPos -= parentWin->geometry().topLeft();
-    if (parent_wayland_window->decoration()) {
-        transientPos.setX(transientPos.x() + parent_wayland_window->decoration()->margins().left());
-        transientPos.setY(transientPos.y() + parent_wayland_window->decoration()->margins().top());
-    }
-
-    uint32_t flags = 0;
-    Qt::WindowFlags wf = m_window->window()->flags();
-    if (wf.testFlag(Qt::ToolTip)
-            || wf.testFlag(Qt::WindowTransparentForInput))
-        flags |= XDG_SURFACE_SET_TRANSIENT_FOR;
-
-    set_transient_for(parent_wayland_window->object());
+// COMCAST MODIFICATION BEGIN
+  //Need to be implemented
+// COMCAST MODIFICATION END
 }
 
 void QWaylandXdgSurface::setTitle(const QString & title)
@@ -195,45 +170,10 @@
     if (m_extendedWindow)
         m_extendedWindow->updateGenericProperty(name, value);
 }
-
-void QWaylandXdgSurface::xdg_surface_configure(int32_t width, int32_t height)
+// MINIMAL IMPLEMENTATION IS PROVIDED. THIS NEED TO BE ENHANCED
+void QWaylandXdgSurface::xdg_surface_configure(int32_t width, int32_t height, wl_array *states, uint32_t serial)
 {
     m_window->configure(0 , width, height);
-}
-
-void QWaylandXdgSurface::xdg_surface_change_state(uint32_t state,
-                                                  uint32_t value,
-                                                  uint32_t serial)
-{
-
-    if (state == XDG_SURFACE_STATE_MAXIMIZED
-            || state == XDG_SURFACE_STATE_FULLSCREEN) {
-        if (value) {
-            m_size = m_window->window()->geometry().size();
-        } else {
-            QMargins m = m_window->frameMargins();
-            m_window->configure(0, m_size.width() + m.left() + m.right(), m_size.height() + m.top() + m.bottom());
-        }
-    }
-
-    switch (state) {
-    case XDG_SURFACE_STATE_MAXIMIZED:
-        m_maximized = value;
-        break;
-    case XDG_SURFACE_STATE_FULLSCREEN:
-        m_fullscreen = value;
-        break;
-    }
-
-    xdg_surface_ack_change_state(object(), state, value, serial);
-}
-
-void QWaylandXdgSurface::xdg_surface_activated()
-{
-}
-
-void QWaylandXdgSurface::xdg_surface_deactivated()
-{
 }
 
 void QWaylandXdgSurface::xdg_surface_close()
diff --git a/src/client/qwaylandxdgsurface_p.h b/src/client/qwaylandxdgsurface_p.h
index f287157..1fea50f 100644
--- a/src/client/qwaylandxdgsurface_p.h
+++ b/src/client/qwaylandxdgsurface_p.h
@@ -102,13 +102,8 @@
     QSize m_size;
     QWaylandExtendedSurface *m_extendedWindow;
 
-    void xdg_surface_configure(int32_t width,
-                               int32_t height) Q_DECL_OVERRIDE;
-    void xdg_surface_change_state(uint32_t state,
-                                  uint32_t value,
-                                  uint32_t serial) Q_DECL_OVERRIDE;
-    void xdg_surface_activated() Q_DECL_OVERRIDE;
-    void xdg_surface_deactivated() Q_DECL_OVERRIDE;
+    void xdg_surface_configure(int32_t width, int32_t height, wl_array *states, uint32_t serial) Q_DECL_OVERRIDE; //COMCAST MODIFICATION
+
     void xdg_surface_close() Q_DECL_OVERRIDE;
 
     friend class QWaylandWindow;
diff --git a/src/compositor/compositor_api/qwaylandcompositor.cpp b/src/compositor/compositor_api/qwaylandcompositor.cpp
index a202c46..a25e471 100644
--- a/src/compositor/compositor_api/qwaylandcompositor.cpp
+++ b/src/compositor/compositor_api/qwaylandcompositor.cpp
@@ -49,7 +49,9 @@
 #include "wayland_wrapper/qwlsurface_p.h"
 #include "wayland_wrapper/qwlinputdevice_p.h"
 #include "wayland_wrapper/qwlinputpanel_p.h"
-#include "wayland_wrapper/qwlshellsurface_p.h"
+// COMCAST MODIFICATION BEGIN
+#include "wayland_wrapper/qxdgshellsurface_p.h"
+// COMCAST MODIFICATION END
 
 #include <QtCore/QCoreApplication>
 #include <QtCore/QStringList>
diff --git a/src/compositor/compositor_api/qwaylandsurface.cpp b/src/compositor/compositor_api/qwaylandsurface.cpp
index 54b3810..6c0984b 100644
--- a/src/compositor/compositor_api/qwaylandsurface.cpp
+++ b/src/compositor/compositor_api/qwaylandsurface.cpp
@@ -46,7 +46,9 @@
 #include "wayland_wrapper/qwlextendedsurface_p.h"
 #include "wayland_wrapper/qwlsubsurface_p.h"
 #include "wayland_wrapper/qwlcompositor_p.h"
-#include "wayland_wrapper/qwlshellsurface_p.h"
+// COMCAST MODIFICATION BEGIN
+#include "wayland_wrapper/qxdgshellsurface_p.h"
+// COMCAST MODIFICATION END
 #include "wayland_wrapper/qwlinputdevice_p.h"
 #include "wayland_wrapper/qwldatadevice_p.h"
 #include "wayland_wrapper/qwldatadevicemanager_p.h"
diff --git a/src/compositor/wayland_wrapper/qwlcompositor.cpp b/src/compositor/wayland_wrapper/qwlcompositor.cpp
index faf32dc..aa85428 100644
--- a/src/compositor/wayland_wrapper/qwlcompositor.cpp
+++ b/src/compositor/wayland_wrapper/qwlcompositor.cpp
@@ -50,7 +50,9 @@
 #include "qwlextendedoutput_p.h"
 #include "qwlextendedsurface_p.h"
 #include "qwlsubsurface_p.h"
-#include "qwlshellsurface_p.h"
+// COMCAST MODIFICATION BEGIN
+#include "qxdgshellsurface_p.h"
+// COMCAST MODIFICATION END
 #include "qwlqttouch_p.h"
 #include "qwlqtkey_p.h"
 #include "qwlinputdevice_p.h"
diff --git a/src/compositor/wayland_wrapper/qwlinputdevice.cpp b/src/compositor/wayland_wrapper/qwlinputdevice.cpp
index 40f2113..4427ef2 100644
--- a/src/compositor/wayland_wrapper/qwlinputdevice.cpp
+++ b/src/compositor/wayland_wrapper/qwlinputdevice.cpp
@@ -60,7 +60,7 @@
 namespace QtWayland {
 
 InputDevice::InputDevice(QWaylandInputDevice *handle, Compositor *compositor, QWaylandInputDevice::CapabilityFlags caps)
-    : QtWaylandServer::wl_seat(compositor->wl_display(), 2)
+    : QtWaylandServer::wl_seat(compositor->wl_display(), 5) // COMCAST MODIFICATION
     , m_handle(handle)
     , m_dragHandle(new QWaylandDrag(this))
     , m_compositor(compositor)
diff --git a/src/compositor/wayland_wrapper/qxdgshellsurface.cpp b/src/compositor/wayland_wrapper/qxdgshellsurface.cpp
new file mode 100644
index 0000000..f7bc462
--- /dev/null
+++ b/src/compositor/wayland_wrapper/qxdgshellsurface.cpp
@@ -0,0 +1,312 @@
+// COMCAST MODIFICATION BEGIN
+#include "qxdgshellsurface_p.h"
+
+#include "qwlcompositor_p.h"
+#include "qwlsurface_p.h"
+#include "qwlinputdevice_p.h"
+#include "qwlsubsurface_p.h"
+#include "qwlpointer_p.h"
+#include "qwlextendedsurface_p.h"
+
+#include "qwaylandsurfaceview.h"
+
+#include <QtCore/qglobal.h>
+#include <QtCore/QDebug>
+
+QT_BEGIN_NAMESPACE
+
+namespace QtWayland {
+
+Shell::Shell()
+{
+}
+
+const wl_interface *Shell::interface() const
+{
+    return &xdg_shell_interface;
+}
+
+void Shell::bind(struct wl_client *client, uint32_t version, uint32_t id)
+{
+    add(client, id, version);
+}
+
+void Shell::xdg_shell_get_xdg_surface(Resource *resource, uint32_t id, struct ::wl_resource *surface_res)
+{
+    Surface *surface = Surface::fromResource(surface_res);
+    new ShellSurface(this, resource->client(), id, surface);
+}
+
+void Shell::xdg_shell_pong(Resource *resource,
+                        uint32_t serial)
+{
+    Q_UNUSED(resource);
+    if (m_pings.remove(serial))
+    {
+      // NEEDS TO BE IMPLEMENTED
+      // emit pong();
+    }
+    else
+        qWarning("Received an unexpected pong!");
+}
+
+void Shell::ping(uint32_t serial)
+{
+    m_pings.insert(serial);
+    send_ping(serial);
+}
+
+
+ShellSurface::ShellSurface(Shell *shell, wl_client *client, uint32_t id, Surface *surface)
+    : QWaylandSurfaceInterface(surface->waylandSurface())
+    , xdg_surface(client, id, 1)
+    , m_shell(shell)
+    , m_surface(surface)
+    , m_resizeGrabber(0)
+    , m_moveGrabber(0)
+{
+    m_view = surface->compositor()->waylandCompositor()->createView(surface->waylandSurface());
+    connect(surface->waylandSurface(), &QWaylandSurface::configure, this, &ShellSurface::configure);
+}
+
+ShellSurface::~ShellSurface()
+{
+    delete m_view;
+}
+
+void ShellSurface::sendConfigure(int32_t width, int32_t height)
+{
+  uint32_t serial;
+  serial = wl_display_next_serial(m_surface->compositor()->wl_display());
+  send_configure(width,height,QByteArray(),serial);
+}
+
+
+void ShellSurface::adjustPosInResize()
+{
+    if (m_surface->transientParent())
+        return;
+    if (!m_resizeGrabber || !(m_resizeGrabber->resize_edges & WL_SHELL_SURFACE_RESIZE_TOP_LEFT))
+        return;
+
+    int bottomLeftX = m_resizeGrabber->point.x() + m_resizeGrabber->width;
+    int bottomLeftY = m_resizeGrabber->point.y() + m_resizeGrabber->height;
+    qreal x = m_view->pos().x();
+    qreal y = m_view->pos().y();
+    if (m_resizeGrabber->resize_edges & WL_SHELL_SURFACE_RESIZE_TOP)
+        y = bottomLeftY - m_view->surface()->size().height();
+    if (m_resizeGrabber->resize_edges & WL_SHELL_SURFACE_RESIZE_LEFT)
+        x = bottomLeftX - m_view->surface()->size().width();
+    QPointF newPos(x,y);
+    m_view->setPos(newPos);
+}
+
+void ShellSurface::resetResizeGrabber()
+{
+    m_resizeGrabber = 0;
+}
+
+void ShellSurface::resetMoveGrabber()
+{
+    m_moveGrabber = 0;
+}
+
+void ShellSurface::setOffset(const QPointF &offset)
+{
+    m_surface->setTransientOffset(offset.x(), offset.y());
+}
+
+void ShellSurface::configure(bool hasBuffer)
+{
+    m_surface->setMapped(hasBuffer);
+}
+
+bool ShellSurface::runOperation(QWaylandSurfaceOp *op)
+{
+    switch (op->type()) {
+        case QWaylandSurfaceOp::Resize:
+            requestSize(static_cast<QWaylandSurfaceResizeOp *>(op)->size());
+            return true;
+        default:
+            break;
+    }
+    return false;
+}
+
+void ShellSurface::requestSize(const QSize &size)
+{
+    sendConfigure(size.width(), size.height());
+}
+
+
+void ShellSurface::xdg_surface_destroy_resource(Resource *)
+{
+    delete this;
+}
+
+void ShellSurface::xdg_surface_move(Resource *resource,
+                struct wl_resource *input_device_super,
+                uint32_t serial)
+{
+    Q_UNUSED(resource);
+    Q_UNUSED(time);
+
+    if (m_resizeGrabber || m_moveGrabber) {
+        qDebug() << "invalid state";
+        return;
+    }
+
+    InputDevice *input_device = InputDevice::fromSeatResource(input_device_super);
+    Pointer *pointer = input_device->pointerDevice();
+
+    m_moveGrabber = new ShellSurfaceMoveGrabber(this, pointer->position() - m_view->pos());
+
+    pointer->startGrab(m_moveGrabber);
+}
+
+void ShellSurface::xdg_surface_resize(Resource *resource,
+                  struct wl_resource *input_device_super,
+                  uint32_t serial,
+                  uint32_t edges)
+{
+    Q_UNUSED(resource);
+    Q_UNUSED(time);
+    Q_UNUSED(edges);
+
+    if (m_moveGrabber || m_resizeGrabber) {
+        qDebug() << "invalid state2";
+        return;
+    }
+
+    m_resizeGrabber = new ShellSurfaceResizeGrabber(this);
+
+    InputDevice *input_device = InputDevice::fromSeatResource(input_device_super);
+    Pointer *pointer = input_device->pointerDevice();
+
+    m_resizeGrabber->point = pointer->position();
+    m_resizeGrabber->resize_edges = static_cast<wl_shell_surface_resize>(edges);
+    m_resizeGrabber->width = m_view->surface()->size().width();
+    m_resizeGrabber->height = m_view->surface()->size().height();
+
+    pointer->startGrab(m_resizeGrabber);
+}
+
+void ShellSurface::xdg_surface_set_minimized(Resource *resource)
+{
+    Q_UNUSED(resource);
+    QSize defaultScreenSize(600,400);
+    sendConfigure(defaultScreenSize.width(), defaultScreenSize.height());
+
+    if (m_surface->extendedSurface())
+        m_surface->extendedSurface()->setVisibility(QWindow::Minimized, false);
+}
+
+void ShellSurface::xdg_surface_set_maximized(Resource *resource)
+{
+    Q_UNUSED(resource);
+    QSize defaultScreenSize(720,540);
+    sendConfigure(defaultScreenSize.width(), defaultScreenSize.height());
+
+    if (m_surface->extendedSurface())
+        m_surface->extendedSurface()->setVisibility(QWindow::Minimized, false);
+}
+
+void ShellSurface::xdg_surface_set_title(Resource *resource,
+                             const QString &title)
+{
+    Q_UNUSED(resource);
+    m_surface->setTitle(title);
+}
+
+ShellSurfaceGrabber::ShellSurfaceGrabber(ShellSurface *shellSurface)
+    : PointerGrabber()
+    , shell_surface(shellSurface)
+{
+}
+
+ShellSurfaceGrabber::~ShellSurfaceGrabber()
+{
+}
+
+ShellSurfaceResizeGrabber::ShellSurfaceResizeGrabber(ShellSurface *shellSurface)
+    : ShellSurfaceGrabber(shellSurface)
+{
+}
+
+void ShellSurfaceResizeGrabber::focus()
+{
+}
+
+void ShellSurfaceResizeGrabber::motion(uint32_t time)
+{
+    Q_UNUSED(time);
+
+    int width_delta = point.x() - m_pointer->position().x();
+    int height_delta = point.y() - m_pointer->position().y();
+
+    int new_height = height;
+    if (resize_edges & WL_SHELL_SURFACE_RESIZE_TOP)
+        new_height = qMax(new_height + height_delta, 1);
+    else if (resize_edges & WL_SHELL_SURFACE_RESIZE_BOTTOM)
+        new_height = qMax(new_height - height_delta, 1);
+
+    int new_width = width;
+    if (resize_edges & WL_SHELL_SURFACE_RESIZE_LEFT)
+        new_width = qMax(new_width + width_delta, 1);
+    else if (resize_edges & WL_SHELL_SURFACE_RESIZE_RIGHT)
+        new_width = qMax(new_width - width_delta, 1);
+
+   shell_surface->sendConfigure(new_width, new_height);
+}
+
+void ShellSurfaceResizeGrabber::button(uint32_t time, Qt::MouseButton button, uint32_t state)
+{
+    Q_UNUSED(time)
+
+    if (button == Qt::LeftButton && !state) {
+        m_pointer->endGrab();
+        shell_surface->resetResizeGrabber();
+        delete this;
+    }
+}
+
+ShellSurfaceMoveGrabber::ShellSurfaceMoveGrabber(ShellSurface *shellSurface, const QPointF &offset)
+    : ShellSurfaceGrabber(shellSurface)
+    , m_offset(offset)
+{
+}
+
+void ShellSurfaceMoveGrabber::focus()
+{
+}
+
+void ShellSurfaceMoveGrabber::motion(uint32_t time)
+{
+    Q_UNUSED(time);
+
+    QPointF pos(m_pointer->position() - m_offset);
+    shell_surface->m_view->setPos(pos);
+    if (shell_surface->m_surface->transientParent()) {
+        QWaylandSurfaceView *view = shell_surface->m_surface->transientParent()->waylandSurface()->views().first();
+        if (view)
+            shell_surface->setOffset(pos - view->pos());
+    }
+
+}
+
+void ShellSurfaceMoveGrabber::button(uint32_t time, Qt::MouseButton button, uint32_t state)
+{
+    Q_UNUSED(time)
+
+    if (button == Qt::LeftButton && !state) {
+        m_pointer->setFocus(0, QPointF());
+        m_pointer->endGrab();
+        shell_surface->resetMoveGrabber();
+        delete this;
+    }
+}
+
+}
+
+QT_END_NAMESPACE
+// COMCAST MODIFICATION END
diff --git a/src/compositor/wayland_wrapper/qxdgshellsurface_p.h b/src/compositor/wayland_wrapper/qxdgshellsurface_p.h
new file mode 100644
index 0000000..6d86b99
--- /dev/null
+++ b/src/compositor/wayland_wrapper/qxdgshellsurface_p.h
@@ -0,0 +1,135 @@
+// COMCAST MODIFICATION BEGIN
+
+#ifndef XDGSHELLSURFACE_H
+#define XDGSHELLSURFACE_H
+
+#include <QtCompositor/qwaylandexport.h>
+#include <QtCompositor/qwaylandsurface.h>
+#include <QtCompositor/qwaylandglobalinterface.h>
+#include <QtCompositor/qwaylandsurfaceinterface.h>
+
+#include <wayland-server.h>
+#include <QHash>
+#include <QPoint>
+#include <QSet>
+#include <private/qwlpointer_p.h>
+#include <QtCompositor/private/qwayland-server-xdg-shell.h>
+
+QT_BEGIN_NAMESPACE
+
+class QWaylandSurfaceView;
+
+namespace QtWayland {
+
+class Compositor;
+class Surface;
+class ShellSurface;
+class ShellSurfaceResizeGrabber;
+class ShellSurfaceMoveGrabber;
+class ShellSurfacePopupGrabber;
+
+class Shell : public QWaylandGlobalInterface, public QtWaylandServer::xdg_shell
+{
+public:
+    Shell();
+
+    const wl_interface *interface() const Q_DECL_OVERRIDE;
+
+    void bind(struct wl_client *client, uint32_t version, uint32_t id) Q_DECL_OVERRIDE;
+    void ping(uint32_t serial);
+
+private:
+    void xdg_shell_get_xdg_surface(Resource *resource, uint32_t id, struct ::wl_resource *surface);
+    void xdg_shell_pong(Resource *resource, uint32_t serial);
+    QSet<uint32_t> m_pings;
+Q_SIGNALS:
+    void pong();
+};
+
+class Q_COMPOSITOR_EXPORT ShellSurface : public QObject, public QWaylandSurfaceInterface, public QtWaylandServer::xdg_surface
+{
+public:
+    ShellSurface(Shell *shell, struct wl_client *client, uint32_t id, Surface *surface);
+    ~ShellSurface();
+    void sendConfigure(int32_t width, int32_t height);
+
+    void adjustPosInResize();
+    void resetResizeGrabber();
+    void resetMoveGrabber();
+
+    void setOffset(const QPointF &offset);
+
+    void configure(bool hasBuffer);
+
+    void requestSize(const QSize &size);
+
+protected:
+    bool runOperation(QWaylandSurfaceOp *op) Q_DECL_OVERRIDE;
+
+private:
+    Shell *m_shell;
+    Surface *m_surface;
+    QWaylandSurfaceView *m_view;
+    ShellSurfaceResizeGrabber *m_resizeGrabber;
+    ShellSurfaceMoveGrabber *m_moveGrabber;
+    void xdg_surface_destroy_resource(Resource *resource) Q_DECL_OVERRIDE;
+
+    void xdg_surface_move(Resource *resource,
+                            struct wl_resource *input_device_super,
+                            uint32_t serial) Q_DECL_OVERRIDE;
+    void xdg_surface_resize(Resource *resource,
+                              struct wl_resource *input_device,
+                              uint32_t serial,
+                              uint32_t edges) Q_DECL_OVERRIDE;
+
+    void xdg_surface_set_minimized(Resource *resource) Q_DECL_OVERRIDE;
+    void xdg_surface_set_maximized(Resource *resource) Q_DECL_OVERRIDE;
+    void xdg_surface_set_title(Resource *resource,
+                                 const QString &title) Q_DECL_OVERRIDE;
+    friend class ShellSurfaceMoveGrabber;
+};
+
+class ShellSurfaceGrabber : public PointerGrabber
+{
+public:
+    ShellSurfaceGrabber(ShellSurface *shellSurface);
+    ~ShellSurfaceGrabber();
+
+    ShellSurface *shell_surface;
+};
+
+class ShellSurfaceResizeGrabber : public ShellSurfaceGrabber
+{
+public:
+    ShellSurfaceResizeGrabber(ShellSurface *shellSurface);
+
+    QPointF point;
+    enum wl_shell_surface_resize resize_edges;
+    int32_t width;
+    int32_t height;
+
+    void focus() Q_DECL_OVERRIDE;
+    void motion(uint32_t time) Q_DECL_OVERRIDE;
+    void button(uint32_t time, Qt::MouseButton button, uint32_t state) Q_DECL_OVERRIDE;
+};
+
+class ShellSurfaceMoveGrabber : public ShellSurfaceGrabber
+{
+public:
+    ShellSurfaceMoveGrabber(ShellSurface *shellSurface, const QPointF &offset);
+
+    void focus() Q_DECL_OVERRIDE;
+    void motion(uint32_t time) Q_DECL_OVERRIDE;
+    void button(uint32_t time, Qt::MouseButton button, uint32_t state) Q_DECL_OVERRIDE;
+
+private:
+    QPointF m_offset;
+};
+
+
+}
+
+QT_END_NAMESPACE
+
+#endif // XDGSHELLSURFACE_H
+// COMCAST MODIFICATION END
diff --git a/src/compositor/wayland_wrapper/wayland_wrapper.pri b/src/compositor/wayland_wrapper/wayland_wrapper.pri
index ac34ae2..76c4e91 100644
--- a/src/compositor/wayland_wrapper/wayland_wrapper.pri
+++ b/src/compositor/wayland_wrapper/wayland_wrapper.pri
@@ -7,6 +7,7 @@
     ../extensions/qtkey-extension.xml \
     ../extensions/windowmanager.xml \
     ../3rdparty/protocol/wayland.xml \
+    ../3rdparty/protocol/xdg-shell.xml \
     ../3rdparty/protocol/input-method.xml \
     ../3rdparty/protocol/text.xml
 
@@ -30,7 +31,7 @@
     wayland_wrapper/qwlqtkey_p.h \
     wayland_wrapper/qwlqttouch_p.h \
     wayland_wrapper/qwlregion_p.h \
-    wayland_wrapper/qwlshellsurface_p.h \
+    wayland_wrapper/qxdgshellsurface_p.h \
     wayland_wrapper/qwlsubsurface_p.h \
     wayland_wrapper/qwlsurface_p.h \
     wayland_wrapper/qwlsurfacebuffer_p.h \
@@ -59,7 +60,7 @@
     wayland_wrapper/qwlqtkey.cpp \
     wayland_wrapper/qwlqttouch.cpp \
     wayland_wrapper/qwlregion.cpp \
-    wayland_wrapper/qwlshellsurface.cpp \
+    wayland_wrapper/qxdgshellsurface.cpp \
     wayland_wrapper/qwlsubsurface.cpp \
     wayland_wrapper/qwlsurface.cpp \
     wayland_wrapper/qwlsurfacebuffer.cpp \
diff --git a/src/hardwareintegration/client/wayland-egl/qwaylandeglwindow.h b/src/hardwareintegration/client/wayland-egl/qwaylandeglwindow.h
index 298dd7d..1ab8757 100644
--- a/src/hardwareintegration/client/wayland-egl/qwaylandeglwindow.h
+++ b/src/hardwareintegration/client/wayland-egl/qwaylandeglwindow.h
@@ -69,8 +69,9 @@
     QSurfaceFormat format() const;
 
     void bindContentFBO();
-
-    void invalidateSurface() Q_DECL_OVERRIDE;
+// COMCAST MODIFICATION BEGIN
+    void invalidateSurface(); //  Q_DECL_OVERRIDE
+// COMCAST MODIFICATION END
 
 private:
     QWaylandEglClientBufferIntegration *m_clientBufferIntegration;
diff --git a/src/hardwareintegration/client/wayland-egl/qwaylandglcontext.cpp b/src/hardwareintegration/client/wayland-egl/qwaylandglcontext.cpp
index 81c74a7..80fc096 100644
--- a/src/hardwareintegration/client/wayland-egl/qwaylandglcontext.cpp
+++ b/src/hardwareintegration/client/wayland-egl/qwaylandglcontext.cpp
@@ -325,7 +325,11 @@
                 }
             }
             m_format.setProfile(QSurfaceFormat::NoProfile);
+// COMCAST MODIFICATION BEGIN
+#if (QT_VERSION > QT_VERSION_CHECK(5, 2, 0))
             m_format.setOptions(QSurfaceFormat::FormatOptions());
+#endif
+// COMCAST MODIFICATION END
             if (m_format.renderableType() == QSurfaceFormat::OpenGL) {
                 // Check profile and options.
                 if (m_format.majorVersion() < 3) {
@@ -514,7 +518,8 @@
     }
 
     eglSwapBuffers(m_eglDisplay, eglSurface);
-
+// COMCAST MODIFICATION
+    m_display->flushRequests();
     window->setCanResize(true);
 }
 
diff --git a/src/hardwareintegration/compositor/wayland-egl/waylandeglclientbufferintegration.cpp b/src/hardwareintegration/compositor/wayland-egl/waylandeglclientbufferintegration.cpp
index 3f7487c..07d7a76 100644
--- a/src/hardwareintegration/compositor/wayland-egl/waylandeglclientbufferintegration.cpp
+++ b/src/hardwareintegration/compositor/wayland-egl/waylandeglclientbufferintegration.cpp
@@ -110,6 +110,9 @@
 void WaylandEglClientBufferIntegration::initializeHardware(QtWayland::Display *waylandDisplay)
 {
     Q_D(WaylandEglClientBufferIntegration);
+// COMCAST MODIFICATION BEGIN
+    d->valid = true;
+// COMCAST MODIFICATION END
 
     const bool ignoreBindDisplay = !qgetenv("QT_WAYLAND_IGNORE_BIND_DISPLAY").isEmpty();
 
@@ -118,8 +121,16 @@
         qWarning("QtCompositor: Failed to initialize EGL display. No native platform interface available.");
         return;
     }
+// COMCAST MODIFICATION BEGIN
+    d->egl_display = eglGetDisplay(reinterpret_cast<EGLNativeDisplayType>(nativeInterface->nativeResourceForWindow("display", m_compositor->window())));
 
-    d->egl_display = nativeInterface->nativeResourceForWindow("EglDisplay", m_compositor->window());
+    EGLint minor, major;
+
+    if (!eglInitialize(d->egl_display,&major,&minor)) {
+        qDebug() << "failed to initialize egl";
+    }
+
+// COMCAST MODIFICATION END
     if (!d->egl_display) {
         qWarning("QtCompositor: Failed to initialize EGL display. Could not get EglDisplay for window.");
         return;
diff --git a/src/plugins/hardwareintegration/client/client.pro b/src/plugins/hardwareintegration/client/client.pro
index b7a9b46..6573b7b 100644
--- a/src/plugins/hardwareintegration/client/client.pro
+++ b/src/plugins/hardwareintegration/client/client.pro
@@ -6,16 +6,5 @@
 config_brcm_egl: \
     SUBDIRS += brcm-egl
 
-config_xcomposite {
-    config_egl: \
-        SUBDIRS += xcomposite-egl
-
-    !contains(QT_CONFIG, opengles2):config_glx: \
-        SUBDIRS += xcomposite-glx
-}
-
-config_drm_egl_server: \
-    SUBDIRS += drm-egl-server
-
 config_libhybris_egl_server: \
     SUBDIRS += libhybris-egl-server
diff --git a/src/plugins/hardwareintegration/compositor/compositor.pro b/src/plugins/hardwareintegration/compositor/compositor.pro
index 215cd25..ffef5ae 100644
--- a/src/plugins/hardwareintegration/compositor/compositor.pro
+++ b/src/plugins/hardwareintegration/compositor/compositor.pro
@@ -13,8 +13,5 @@
         SUBDIRS += xcomposite-glx
 }
 
-config_drm_egl_server: \
-    SUBDIRS += drm-egl-server
-
 config_libhybris_egl_server: \
     SUBDIRS += libhybris-egl-server
diff --git a/src/plugins/platforms/platforms.pro b/src/plugins/platforms/platforms.pro
index 0665511..d153adf 100644
--- a/src/plugins/platforms/platforms.pro
+++ b/src/plugins/platforms/platforms.pro
@@ -11,12 +11,5 @@
 contains(CONFIG, wayland-compositor) {
     config_brcm_egl: \
         SUBDIRS += qwayland-brcm-egl
-
-    config_xcomposite {
-        config_egl: \
-            SUBDIRS += qwayland-xcomposite-egl
-        !contains(QT_CONFIG, opengles2):config_glx: \
-            SUBDIRS += qwayland-xcomposite-glx
-    }
 }
 
